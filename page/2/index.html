<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>点滴诗词</title>
    <meta name="author" content="shiguofu">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content="好玩有趣长知识">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="点滴诗词" type="application/atom+xml">
    
    
    <link rel="icon" href="http://shiguofu.cn/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">点滴诗词</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/backend">
                <span class="nav-text">后端</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="http://shiguofu2012.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="http://shiguofu.cn/static/images/diandi.jpg" title="公众号：itman-1">
                </a>
            </div>
            
            <div class="author-name">公众号：itman-1</div>
            <div class="author-work">程序猿，苦B奋斗的伪文艺老年</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">wuhan, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/shiguofu2012" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="http://weibo.com/shiguofu2012" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com/shiguofu2012" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2021/01/07/grpc_tracing/">gRPC tracing</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-01-07T05:19:59.000Z" itemprop="datePublished">2021-01-07</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Golang/">Golang</a>, <a class="article-tag-link" href="/tags/service/">service</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC是什么可以用官网的一句话来概括</p>
<blockquote>
<p>A high-performance, open-source universal RPC framework</p>
</blockquote>
<p><strong>所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</strong>如下图所示就是一个典型的RPC结构图。</p>
<p><img src="/2021/01/07/grpc_tracing/3959253-76284b64125a8673.png" alt="img"></p>
<h3 id="gRPC-vs-Restful-API"><a href="#gRPC-vs-Restful-API" class="headerlink" title="gRPC vs. Restful API"></a>gRPC vs. Restful API</h3><p>既然是server/client模型，那么我们直接用restful api不是也可以满足吗，为什么还需要RPC呢？</p>
<p>gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：</p>
<ul>
<li>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。</li>
<li>另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</li>
<li>gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li>
</ul>
<h3 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h3><p>微服务遍地都是，一个功能，一个接口都可能是一个微服务，微服务之间的调用混乱，无法追踪，很难找出瓶颈点，因此迫切需要一种方法来追踪服务之间的调用链路。</p>
<ul>
<li>MetaData</li>
</ul>
<p>Metadata 可以理解为一个 HTTP 请求的 Header（它的底层实现就是 HTTP/2 的 Header），用户可以通过访问和修改每个 gRPC Call 的 Metadata 来传递额外的信息：比如认证信息，比如用于追踪的 Request ID。</p>
<ul>
<li>interceptor</li>
</ul>
<p>Interceptor 有点类似于我们平时常用的 HTTP Middleware，不同的是它可以用在 Client 端和 Server 端。比如在收到请求之后输出日志，在请求出现错误的时候输出错误信息，比如获取请求中设置的 Request ID。</p>
<ul>
<li>Golang实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnaryInvoker is called by UnaryClientInterceptor to complete RPCs.</span></span><br><span class="line"><span class="keyword">type</span> UnaryInvoker <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, opts ...CallOption)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">UnaryClientInterceptor</span> <span class="title">intercepts</span> <span class="title">the</span> <span class="title">execution</span> <span class="title">of</span> <span class="title">a</span> <span class="title">unary</span> <span class="title">RPC</span> <span class="title">on</span> <span class="title">the</span> <span class="title">client</span>. <span class="title">invoker</span> <span class="title">is</span> <span class="title">the</span> <span class="title">handler</span> <span class="title">to</span> <span class="title">complete</span> <span class="title">the</span> <span class="title">RPC</span></span></span><br><span class="line"><span class="function">// <span class="title">and</span> <span class="title">it</span> <span class="title">is</span> <span class="title">the</span> <span class="title">responsibility</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interceptor</span> <span class="title">to</span> <span class="title">call</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function">// <span class="title">This</span> <span class="title">is</span> <span class="title">an</span> <span class="title">EXPERIMENTAL</span> <span class="title">API</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">UnaryClientInterceptor</span> <span class="title">func</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, req, reply <span class="keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">UnaryHandler</span> <span class="title">defines</span> <span class="title">the</span> <span class="title">handler</span> <span class="title">invoked</span> <span class="title">by</span> <span class="title">UnaryServerInterceptor</span> <span class="title">to</span> <span class="title">complete</span> <span class="title">the</span> <span class="title">normal</span></span></span><br><span class="line"><span class="function">// <span class="title">execution</span> <span class="title">of</span> <span class="title">a</span> <span class="title">unary</span> <span class="title">RPC</span>. <span class="title">If</span> <span class="title">a</span> <span class="title">UnaryHandler</span> <span class="title">returns</span> <span class="title">an</span> <span class="title">error</span>, <span class="title">it</span> <span class="title">should</span> <span class="title">be</span> <span class="title">produced</span> <span class="title">by</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">status</span> <span class="title">package</span>, <span class="title">or</span> <span class="title">else</span> <span class="title">gRPC</span> <span class="title">will</span> <span class="title">use</span> <span class="title">codes</span>.<span class="title">Unknown</span> <span class="title">as</span> <span class="title">the</span> <span class="title">status</span> <span class="title">code</span> <span class="title">and</span> <span class="title">err</span>.<span class="title">Error</span><span class="params">()</span> <span class="title">as</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">status</span> <span class="title">message</span> <span class="title">of</span> <span class="title">the</span> <span class="title">RPC</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">UnaryHandler</span> <span class="title">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">UnaryServerInterceptor</span> <span class="title">provides</span> <span class="title">a</span> <span class="title">hook</span> <span class="title">to</span> <span class="title">intercept</span> <span class="title">the</span> <span class="title">execution</span> <span class="title">of</span> <span class="title">a</span> <span class="title">unary</span> <span class="title">RPC</span> <span class="title">on</span> <span class="title">the</span> <span class="title">server</span>. <span class="title">info</span></span></span><br><span class="line"><span class="function">// <span class="title">contains</span> <span class="title">all</span> <span class="title">the</span> <span class="title">information</span> <span class="title">of</span> <span class="title">this</span> <span class="title">RPC</span> <span class="title">the</span> <span class="title">interceptor</span> <span class="title">can</span> <span class="title">operate</span> <span class="title">on</span>. <span class="title">And</span> <span class="title">handler</span> <span class="title">is</span> <span class="title">the</span> <span class="title">wrapper</span></span></span><br><span class="line"><span class="function">// <span class="title">of</span> <span class="title">the</span> <span class="title">service</span> <span class="title">method</span> <span class="title">implementation</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">the</span> <span class="title">responsibility</span> <span class="title">of</span> <span class="title">the</span> <span class="title">interceptor</span> <span class="title">to</span> <span class="title">invoke</span> <span class="title">handler</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">complete</span> <span class="title">the</span> <span class="title">RPC</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">UnaryServerInterceptor</span> <span class="title">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>Golang 的实现是把 Metadata 塞在了 context 里面，只需要使用 <code>metadata.FromOutgoingContext(ctx)</code> 和 <code>metadata.FromIncomingContext(ctx)</code> 就能够访问本次请求的 Metadata。概念清楚之后代码应该非常好写了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestIdKey = <span class="string">"requestId"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// client 请求RPC增加MetaData拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestIDClientInterceptor</span><span class="params">()</span> <span class="title">grpc</span>.<span class="title">UnaryClientInterceptor</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">		method <span class="keyword">string</span>, req, resp <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">		cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption,</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求的MetaData</span></span><br><span class="line">		md, ok := metadata.FromOutgoingContext(ctx)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="comment">// 未添加则创建</span></span><br><span class="line">			md = metadata.Pairs()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		value := ctx.Value(requestIdKey)</span><br><span class="line">		<span class="keyword">if</span> requestID, ok := value.(<span class="keyword">string</span>); ok &amp;&amp; requestID != <span class="string">""</span> &#123;</span><br><span class="line">      <span class="comment">// md 不区分大小写，内部会转换为小写</span></span><br><span class="line">      md.Set(requestIdKey, requestID)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> invoker(metadata.NewOutgoingContext(ctx, md), method, req, resp, cc, opts...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server端获取MetaData数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestIDServerInterceptor</span><span class="params">()</span> <span class="title">grpc</span>.<span class="title">UnaryServerInterceptor</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">		req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span> <span class="params">(resp <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求过来的MetaData</span></span><br><span class="line">		md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			md = metadata.Pairs()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 后去请求的requstId，并设置到当前context中</span></span><br><span class="line">		requestIDs := md[requestIdKey]</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(requestIDs) &gt;= <span class="number">1</span> &#123;</span><br><span class="line">			ctx = context.WithValue(ctx, requestIdKey, requestIDs[<span class="number">0</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2021/01/04/logrotate-config/">日志切割工具 logrotate 配置</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-01-04T13:30:00.000Z" itemprop="datePublished">2021-01-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/service/">service</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>Linux一般是默认自带logrotate的，如果没有可以使用yum/apt安装</p>
<h4 id="apt-yum-安装"><a href="#apt-yum-安装" class="headerlink" title="apt/yum 安装"></a>apt/yum 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-145-82-centos ~]# yum install logrotate</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Package logrotate-3.8.6-14.tl2.x86_64 already installed and latest version</span><br><span class="line">Nothing to do</span><br><span class="line">[root@VM-145-82-centos ~]#</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@VM-0-15-ubuntu:[10:59:47]:~# apt-get install logrotate</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">logrotate is already the newest version (3.8.7-2ubuntu2.16.04.2).</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 385 not upgraded.</span><br></pre></td></tr></table></figure>

<h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p>github地址: <a href="https://github.com/logrotate/logrotate" target="_blank" rel="noopener">https://github.com/logrotate/logrotate</a> </p>
<p>按照github安装</p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>logrotate是利用系统crontab定时执行的，在目录/etc/cron.daily中有个logrotate的脚本。如果需要，可以在cron.hourly，也可以在/etc/crontab中增加自己的配置。</p>
<p>这些配置都是独立的，结合自己的配置以及服务的日志量来自定义达到最优配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line">/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf</span><br><span class="line">EXITVALUE=$?</span><br><span class="line">if [ $EXITVALUE != 0 ]; then</span><br><span class="line">    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>配置文件主要存放在目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-145-82-centos ~]# ls /etc/logrotate.d/</span><br><span class="line">conman  cron.30m  iptraf-ng  mgetty  mongodb  mysql  psacct  syslog  yum</span><br></pre></td></tr></table></figure>

<p>一般安装会添加常用组件的配置，在生产环境中，我们会自定义一些配置。</p>
<p>如下是本人常用的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/data/log/*.log</span><br><span class="line">&#123;</span><br><span class="line">    daily</span><br><span class="line">    notifempty    </span><br><span class="line">    copytruncate</span><br><span class="line">    compress</span><br><span class="line">    rotate 60</span><br><span class="line">    missingok</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>配置参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>monthly</strong></td>
<td>日志文件将按月轮循。其它可用值为’daily’，’weekly’或者’yearly’。</td>
</tr>
<tr>
<td><strong>rotate 5</strong></td>
<td>一次将存储5个归档日志。对于第六个归档，时间最久的归档将被删除。</td>
</tr>
<tr>
<td><strong>compress</strong></td>
<td>在轮循任务完成后，已轮循的归档将使用gzip进行压缩。</td>
</tr>
<tr>
<td><strong>delaycompress</strong></td>
<td>总是与compress选项一起用，delaycompress选项指示logrotate不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用。</td>
</tr>
<tr>
<td><strong>missingok</strong></td>
<td>在日志轮循期间，任何错误将被忽略，例如“文件无法找到”之类的错误。</td>
</tr>
<tr>
<td><strong>notifempty</strong></td>
<td>如果日志文件为空，轮循不会进行。</td>
</tr>
<tr>
<td><strong>create 644 root root</strong></td>
<td>以指定的权限创建全新的日志文件，同时logrotate也会重命名原始日志文件。</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>日志文件大小的配置，如果没达到这个大小，将不会压缩</td>
</tr>
<tr>
<td><strong>dateext</strong></td>
<td>压缩文件带上日期，默认会使用编号(log.log.1.gz)，该选项会是每次压缩都带上日期，如 log.log-2020</td>
</tr>
<tr>
<td><strong>dateformat</strong></td>
<td>日期格式  支持 %Y%m%d(年月日) %s(时间戳)</td>
</tr>
<tr>
<td><strong>postrotate/endscript</strong></td>
<td>在所有其它指令完成后，postrotate和endscript里面指定的命令将被执行。在这种情况下，rsyslogd 进程将立即再次读取其配置并继续运行。</td>
</tr>
</tbody></table>
<h3 id="3-执行频度定制"><a href="#3-执行频度定制" class="headerlink" title="3. 执行频度定制"></a>3. 执行频度定制</h3><p>logrotate是在cron中执行的，因此要自定义执行频度，可以增加crontab配置</p>
<p>比如，我们的服务需要每半小时压缩一次 hourly是不满足我们的需求，就需要在crontab中增加一条记录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-145-82-centos /etc/logrotate.d/cron.30m]# crontab -e</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> rotate nginx log every 30min</span><br><span class="line">*/30 * * * * /usr/sbin/logrotate  /etc/logrotate.d/cron.30m/*  -f</span><br></pre></td></tr></table></figure>

<p>可以将30min执行的所有配置文件放到一个目录，执行30min命令。</p>
<h4 id="4-手动执行"><a href="#4-手动执行" class="headerlink" title="4. 手动执行"></a>4. 手动执行</h4><p>配置文件是否配置成功，执行后是什么效果。logrotate提供测试的功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-145-82-centos /etc/logrotate.d/cron.30m]# logrotate -d /etc/logrotate.d/cron.30m/*</span><br><span class="line">reading config file /etc/logrotate.d/cron.30m/nginx</span><br><span class="line">Allocating hash table for state file, size 15360 B</span><br><span class="line"></span><br><span class="line">Handling 1 logs</span><br><span class="line"></span><br><span class="line">rotating pattern: /var/log/nginx/*log  after 1 days (10 rotations)</span><br><span class="line">empty log files are not rotated, old logs are removed</span><br><span class="line">considering log /var/log/nginx/access.log</span><br><span class="line">  log does not need rotating (log is empty)considering log /var/log/nginx/error.log</span><br><span class="line">  log does not need rotating (log is empty)not running postrotate script, since no logs were rotated</span><br></pre></td></tr></table></figure>

<p>执行后，会输出文件怎么变更，压缩重命名等。比如上面会提示 “old logs are removed” “10 rotate” 等记录。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>logrotate工具对于防止因庞大的日志文件而耗尽存储空间是十分有用的。配置完毕后，进程是全自动的，可以长时间在不需要人为干预下运行。可以根据需求及日志量定制自己的日志切割规则。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2021/01/03/Golang-Context详解/">Golang context 源码分析</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2021-01-03T15:00:00.000Z" itemprop="datePublished">2021-01-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Golang/">Golang</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>一般接触新东西都会有三问(what/why/how),我们也从这几个角度看下golang context。</p>
<h3 id="WHAT-IS-CONTEXT"><a href="#WHAT-IS-CONTEXT" class="headerlink" title="WHAT IS CONTEXT"></a>WHAT IS CONTEXT</h3><p>Goroutine和Channel是go语言的特色，并发编程会使用协程来处理工作，通道用来协程之间的通信。主协程创建子协程，子协程再创建子协程，就会形成一个协程树状结构，协程之间可以采用通道来进行通信。<br>每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态都会封装Context变量中，传递给要执行的Goroutine中。比如在网络编程中，处理一个网络Request时，我们可能需要开启不同的Goroutine来获取数据与逻辑处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request异常、超时或者被取消的时候，所有从这个Request创建的所有Goroutine都应该被结束。</p>
<h3 id="WHY-CONTEXT"><a href="#WHY-CONTEXT" class="headerlink" title="WHY CONTEXT"></a>WHY CONTEXT</h3><p>上面我们说过，由于异常、超时或者被取消的情况，都应该结束该Request创建的所有Goroutine。假如不用context，我们看怎么去控制协程树。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> services</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 使用一个chan来控制协程的退出</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(data)</span><br><span class="line">	<span class="comment">// consumer</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				fmt.Println(<span class="string">"child process interrupt..."</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Printf(<span class="string">"send message: %d\n"</span>, &lt;-data)</span><br><span class="line">				time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// producer</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		data &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="comment">// 退出协程</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"main process exit!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子协程运行着任务，如果主协程需要在某个时刻发送消息通知子协程中断任务退出，那么就可以让子协程监听这个done channel，一旦主协程关闭done channel，那么子协程就可以推出了，这样就实现了主协程通知子协程的需求。这种方式运行良好，但是这也是有限的。<br>考虑这种情况：如果主协程中有多个任务1, 2, …n，主协程对这些任务有时间限制；而任务1又有多个子任务1, 2, …，k, 任务1对这些子任务也有自己的时间控制，那么这些子任务既要感知主协程的取消信号，也需要感知任务1的取消信号。<br>如果使用done channel的用法，这个时候需要定义两个done channel，子任务们需要同时监听这两个done channel,这样也可以正常work。但是如果层级更深，如果这些子任务还有子任务，那么使用done channel的方式将会变得非常繁琐且混乱。<br>这个时候 context出场了。</p>
<h3 id="context-interface"><a href="#context-interface" class="headerlink" title="context interface"></a>context interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context包含四个方法</p>
<ul>
<li>Deadline 返回绑定当前context的任务执行的截止时间，如果没有截止时间，则ok==false</li>
<li>Done 该函数返回一个只读的chan 数据是空结构体，类似我们上面的done，控制协程的退出</li>
<li>Err 如果协程退出，该函数返回退出的原因，被取消或者执行超时等错误</li>
<li>Value 获取context中传递的值</li>
</ul>
<p>可以看到Done方法返回的chan正是用来传递结束信号以抢占并中断当前任务的；Deadline方法用来表示gorotine是否在指定时间被取消；Err方法是用来解释goroutine被取消的原因；而Value则用于获取特定于当前任务的数据。<br>而context所包含的额外信息键值对是如何存储的呢？其实可以想象一颗树，树的每个节点可能携带一组键值对,如果当前节点上无法找到key所对应的值，就会向上去父节点里找，直到根节点，具体后面会说到。</p>
<p>下面我们看下context的两个比较常用的实现，valueCtx/cancelCtx</p>
<h4 id="valueCtx"><a href="#valueCtx" class="headerlink" title="valueCtx"></a>valueCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构比较简单就是增加了key/val字段存储键值对<br>WithValue用以向其中存储键值对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里添加键值对不是直接在原context结构体上直接添加，而是重新创建一个新的valueCtx节点，作为原ctx的子节点，并将键值对添加在子节点上，由此形成一条链表。获取value就是从这条链表上尾部向前搜寻(代码如下)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueCtx的增加值与获取值的过程如下：<br>With就是往链表的尾部增加节点，value就是从尾部开始获取对应的值，找到就退出；否则找到头部返回空.</p>
<p><img src="/2021/01/03/Golang-Context详解/1607008927_6_w733_h99.png" alt="enter image description here"></p>
<h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cancelCtx是一个可以取消的 Context，实现了 canceler 接口。它直接将接口 Context 作为它的一个匿名字段，这样，它就可以被看成一个 Context。done是一个空结构体类型的channel，用来传递关闭信号，在协程中一般结合select来监听父协程退出信号；children是一个map，存储了所有可取消context的子节点，这样任意层级的context取消，都会给所有子context发送取消信号；err用于存储错误信息表示任务结束的原因。<br>先看下Done方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    d := c.done</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c.done懒汉式创建，调用Done方法才会创建。返回一个只读的chan,一般结合select监听。一旦取消，立马可读。<br>重点看下cancel方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 必须要传 err</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 已经被其他协程取消</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 err 字段赋值</span></span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="comment">// 关闭 channel，通知其他协程</span></span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历它的所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// 递归地取消所有子节点</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将子节点置空</span></span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        <span class="comment">// 从父节点中移除自己 </span></span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来看，cancel() 方法的功能就是关闭 channel：c.done；递归地取消所有的子节点；将自己从父节点树中摘掉。通过关闭 channel，goroutine 这边接收取消信号的方式就是 select 语句中的读 ctx.Done 可读，执行相应的退出函数。<br>这里有个比较巧妙的地方，调用子节点 cancel 方法的时候，传入的第一个参数是 false，最终子节点是没有调用removeChild，把自己从父节点移除。<br>移除的操作很简单，找到最近的可取消的祖先节点，将自己从其map中删除。最关键的一行：delete(p.children, child)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeChild</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 查找最近的可取消节点</span></span><br><span class="line">    p, ok := parentCancelCtx(parent)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> p.children != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 从最近的祖先节点的map中移除自己</span></span><br><span class="line">        <span class="built_in">delete</span>(p.children, child)</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那什么时候需要移除，什么时候不需要移除呢？<br>我们先来看下创建一个可取消的context。<br>WithCancel函数创建一个可取消的context，即cancelCtx类型的context,传入一个父context，返回context和CancelFunc，调用CancelFunc即可触发cancel操作。直接看源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;  <span class="comment">// 这里cancel传入了true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，只有在使用WithCancel创建context的时候，返回的cancelFunc会传入true。这样当调用cancelFunc 时，会将这个 可取消的context从它的父节点里移除，因为父节点可能有很多子节点，取消之后要和父节点断绝关系，对其他没影响。而对于该context的所有子节点都会因为该节点的cancelFunc调用c.children = nil而化为灰烬，没有必要再一个一个移除。</p>
<p><img src="/2021/01/03/Golang-Context详解/1607065426_62_w865_h334.png" alt="enter image description here"></p>
<p>如上左图，代表一棵 context 树，当然也可以看做是一个协程树。当调用左图子context的cancel 方法后，该 context会依次调用children中的cancel的方法，此时子context不会移除自己；该context将自己从它的父 context中去除掉了：从children中delete，实线箭头变成了虚线。且虚线圈框出来的 context 都被取消了，圈内的 context间的父子关系都被取消掉了。<br>再重点看propagateCancel()：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 父节点是个空节点</span></span><br><span class="line">    <span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到可以取消的父 context</span></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 父节点已经被取消了，本节点（子节点）也要取消</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 父节点未取消</span></span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// "挂到"父节点上</span></span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到可取消的父 context。新启动一个协程监控父节点或子节点取消信号</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的功能就是向上寻找可以“依靠”的“可取消”的context，并且“挂靠”上去。这样，调用上层cancel方法的时候，就可以层层传递，将那些挂靠的子context同时“取消”。<br>这里也有一个比较巧妙的设计，就是else的情况。起初我一直不理解，怎么可能会有else的情况发生，parent.Done()不为空，怎么会找不到可取消的父节点。这里要翻看parentCancelCtx的源码了。。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span> <span class="params">(*cancelCtx, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> c := parent.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">return</span> c, <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">return</span> &amp;c.cancelCtx, <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            parent = c.Context</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只会找三种Context类型：cancelCtx，timerCtx，*valueCtx。若是把Context内嵌到自定义类型里，就识别不出来了，就会走default了。为避免这种情况父节点取消传递不到当前节点之后的节点，重新启动了一个协程来传递这种情况，所以使用可取消的context的时候，尽量避免将ctx塞入自定义的结构里，不然会多一个协程来处理。<br>另一个巧妙的地方就是select</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">    <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时监听了父节点是否退出，也监听当前节点是否退出。这二者缺一不可。</p>
<p>第一个case 好理解，上层几点取消要继续传递下去，就监听了上层是否被取消。</p>
<p>第二个case 如果子节点自己退出了，那就不需要这个协程了，他的作用就是为了连接上层节点与自己。但如果去掉这个case，上层协程一直不取消，那这个goroutine就泄漏了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>context主要用于处理父子协程之间的同步取消信号，本质上是一种协程同步调用协调的方式。<br>在使用context的时候，有两点要注意：</p>
<ul>
<li>父协程只是使用context通知所有的子协程，我已经不需要你了，但不会直接干涉和中断下游任务的执行，具体的操作是由子协程决定操作，因此子协程要使用select来监听ctx.Done。</li>
<li>context是线程安全的，可以放心地在多个协程中传递使用。</li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/05/19/leetcode两个正序数组的中位数/">Leetcode 两个正序数组的中位数</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-19T14:35:20.000Z" itemprop="datePublished">2020-05-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/algorithm/">algorithm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="leetcode-两个正序数组的中位数"><a href="#leetcode-两个正序数组的中位数" class="headerlink" title="leetcode 两个正序数组的中位数"></a>leetcode 两个正序数组的中位数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</span><br><span class="line"></span><br><span class="line">请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</span><br><span class="line"></span><br><span class="line">你可以假设 nums1 和 nums2 不会同时为空。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>

<h4 id="正常思路"><a href="#正常思路" class="headerlink" title="正常思路"></a>正常思路</h4><p>这道题，感觉在于理解什么是中位数</p>
<p>基本思路就是把两个数组合并，但是只需要合并到 总数/2 就可以了 后面可以忽略</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) &lt; len(nums2):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        index1 = <span class="number">0</span></span><br><span class="line">        index2 = <span class="number">0</span></span><br><span class="line">        total = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">while</span> index2 &lt; len(nums2) <span class="keyword">and</span> index1 &lt;= total / <span class="number">2</span>:     <span class="comment"># 结束条件</span></span><br><span class="line">            <span class="keyword">if</span> index1 &lt; len(nums1):								<span class="comment"># 两数组等长，数组1最大的数小雨数组2最小的数，会导致index1==len(nums1) index1 out of range</span></span><br><span class="line">                <span class="keyword">if</span> nums1[index1] &gt; nums2[index2]:</span><br><span class="line">                    nums1.insert(index1, nums2[index2])</span><br><span class="line">                    index2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1.append(nums2[index2])			<span class="comment"># 只要把数组2append到最后</span></span><br><span class="line">                index2  += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[int(total / <span class="number">2</span>) - <span class="number">1</span>] + nums1[int(total / <span class="number">2</span>)]) / <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[total / <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="新的思路"><a href="#新的思路" class="headerlink" title="新的思路"></a>新的思路</h4><p>我们这个算法时间复杂度是 O(m+n) ,题目有个要求 算法时间复杂度  O(log(m + n))，倘若没这个要求 上面的算法就可以完成了，但是有复杂度 并且是log的，这个时候我们可以想起是二分查找。</p>
<p>先来理解一下， 两个有序数组，中位数 可以理解寻找两个数据的第n/2+1大的数（奇数个数）或者第n/2与n/2+1个大的数的平均值。</p>
<p>我们思考，既然是二分查找，思路应该是第一次二分排除掉一部分 然后继续找。</p>
<p>假设 两个数组A与B， 要找第k大的数， 我们可以比较 A[k/2-1]与B[k/2-1] ，为啥？</p>
<p> 因为 A与B数组前面各有 k/2-2个数 ，比较他俩 有几种情况： </p>
<ul>
<li>A[k/2-1]&gt;B[k/2-1]  </li>
</ul>
<p>这说明A[k/2-1] 前面那个数(也就是A[k/2-2]) 要么等于A[k/2-1]要么大于A[k/2-1] (因为A有序) ，再来看A[k/2-2]与B数组的关系， 他与B[k/2-1] 的关系，也就是如果合并，A[k/2-2]一定是在B[k/2-1]这个数后面，也就是说A[k/2-2]前面有 B[k/2-1]这个数前面的所有数 有k/2-1个+A数组前面 k/2-2 = k-3个数，这第k个数 一定是在 B[k/2] ~ B[n] 与 A[0] ~ A[m]之间 这个时候可以把  B[k/2] ~ B[n] 看称一个新的数组， A[0] ~ A[m]看成另一个数组，这个时候k已经变成了k-(k/2-1)了， 也就是新的两个数组的k-(k/2-1)大的数， 第继续比较 两个数组的 k/2-1个数，如此循环。</p>
<ul>
<li>A[k/2-1]&lt;B[k/2-1]  </li>
</ul>
<p>这个时候跟上面的情况相反，只需要间隔A折半 A[k/2] ~A[m] 与 B[0] ~ B[n]</p>
<ul>
<li>A[k/2-1]==B[k/2-1]  </li>
</ul>
<p>相等的情况， 前面有k-4个数 他俩一个是 k-3 一个是k-2 没找到第k个数 还是要找，肯定是在A[k/2] ~ A[m] 与 B[k/2] ~ B[n] 这里可以按照跟情况一或者情况二处理都一样的，都是往后移动一个。</p>
<p>这就是二分法查找，每次排除数组一半的数据.</p>
<p>举个例子两个数组：</p>
<p>长度 13/2+1 =7 要找到第7大的数就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>第一次 比较 A[7/2-1] ? B[7/2-1] </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 &lt;4&gt; 9</span><br><span class="line">B: 1 2 &lt;3&gt; 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>之后数组变为以下结果，变为查找第 7 - 3  = 4大的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>重新比较 A[4/2-1] ? B[4/2-1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 &lt;3&gt; 4 9</span><br><span class="line">B: 4 &lt;5&gt; 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>出现相等了，只要改一个就可以, 查找 4 - 2 = 2大的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 4 9</span><br><span class="line">B: 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>比较 A[2/2-1] ? B[2/2-1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: &lt;4&gt; 9</span><br><span class="line">B: &lt;4&gt; 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>相等的场景，可以任意一个，这里就选择移动A数组了, 2 - 1 = 1 大的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: &lt;9&gt;</span><br><span class="line">B: &lt;4&gt; 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>这里已经是第1大的数了 就是最小的那个了，直接比较A[1/2-1] ? B[1/2-1] ===&gt; A[0] ? B[0]</p>
<p>这里找到了 B[0]即 4</p>
<p>假如这个这里找的不是第7大，而是第八大,这里要继续找继续下一组数组就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 9</span><br><span class="line">B: 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>找到了5.</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>这种场景很容易想到 用递归的方式来处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindK</span><span class="params">(a []<span class="keyword">int</span>, b[]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一个数组已经空了，直接找另一个数组的第k大的数 下标是k-1</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b[k<span class="number">-1</span>]</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[k<span class="number">-1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到了</span></span><br><span class="line">  <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min(a[<span class="number">0</span>],b[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较两个数组的中位数</span></span><br><span class="line">  index := k / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// index不能超过数组长度</span></span><br><span class="line">  newIndexA := min(index, <span class="built_in">len</span>(a)<span class="number">-1</span>)</span><br><span class="line">  newIndexB := min(index, <span class="built_in">len</span>(b)<span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> a[newIndexA] &gt; b[newIndexB] &#123; <span class="comment">// 比较并移动新的数组</span></span><br><span class="line">    newIndexB += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> FindK(a, b[newIndexB:], k-newIndexB)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newIndexA += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> FindK(a[newIndexA:], b, k-newIndexA)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    total := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">2</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        r := FindK(nums1, nums2, total/<span class="number">2</span>+<span class="number">1</span>) <span class="comment">// 奇数 刚好是中间的数字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line">    index := total / <span class="number">2</span> <span class="comment">// 偶数</span></span><br><span class="line">    a := FindK(nums1, nums2, index)</span><br><span class="line">    b := FindK(nums1, nums2, index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(a + b) / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下非递归的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindK</span><span class="params">(a []<span class="keyword">int</span>, b[]<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  indexA, indexB := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> indexA &gt;= <span class="built_in">len</span>(a) || <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b[indexB+k<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> indexB &gt;= <span class="built_in">len</span>(b) || <span class="built_in">len</span>(b) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a[indexA+k<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> min(a[indexA], b[indexB])</span><br><span class="line">    &#125;</span><br><span class="line">    newIndexB := min(indexB+k/<span class="number">2</span><span class="number">-1</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>)</span><br><span class="line">    newIndexA := min(indexA+k/<span class="number">2</span><span class="number">-1</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> a[newIndexA] &gt; b[newIndexB] &#123;</span><br><span class="line">      k = k - (newIndexB-indexB+<span class="number">1</span>)</span><br><span class="line">      indexB = newIndexB + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k = k - (newIndexA - indexA+<span class="number">1</span>)</span><br><span class="line">      indexA = newIndexA + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于，花了两个晚上 弄懂了以上一个非常简单的算法，深感智商有限，你的努力在天赋面前不值一提，你努力达到的高度，可能是别人的起点。</p>
<p>平凡人的努力，终究是徒劳。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/05/19/redis-内存淘汰策略/">redis 内存淘汰策略</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-19T14:35:20.000Z" itemprop="datePublished">2020-05-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/redis/">redis</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="redis-内存淘汰策略"><a href="#redis-内存淘汰策略" class="headerlink" title="redis 内存淘汰策略"></a>redis 内存淘汰策略</h4><p>将 Redis 用作缓存时, 如果内存空间用满, 就会根据配置的最大内存策略返回错误或者自动驱逐老的数据。</p>
<h5 id="maxmemory-配置指令"><a href="#maxmemory-配置指令" class="headerlink" title="maxmemory 配置指令"></a>maxmemory 配置指令</h5><p>maxmemory 用于指定 Redis 能使用的最大内存。既可以在 <code>redis.conf</code> 文件中设置, 也可以在运行过程中通过 CONFIG SET 命令动态修改。</p>
<p>例如, 要设置 100MB 的内存限制, 可以在 <code>redis.conf</code> 文件中这样配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure>

<p>将 <code>maxmemory</code> 设置为 0, 则表示不进行内存限制。当然, 对32位系统来说有一个隐性的限制条件: 最多 3GB 内存.</p>
<h5 id="内存淘汰策略-maxmemory-policy"><a href="#内存淘汰策略-maxmemory-policy" class="headerlink" title="内存淘汰策略(maxmemory-policy)"></a>内存淘汰策略(maxmemory-policy)</h5><ul>
<li><strong>noeviction</strong></li>
</ul>
<p>不删除，达到最大内存，如果继续写(新增)数据，直接返回错误信息。DEL还是可以正常执行。</p>
<ul>
<li><strong>allkeys-lru</strong></li>
</ul>
<p>所有key范围，优先删除最近最少使用(LRU)</p>
<ul>
<li><strong>volatile-lru</strong></li>
</ul>
<p>只限于设置了expire的部分，优先删除最近最少使用(LRU)的key</p>
<ul>
<li><strong>allkeys-random</strong></li>
</ul>
<p>所有key范围，随机删除一部分key</p>
<ul>
<li><strong>volatile-random</strong></li>
</ul>
<p>只限于设置了expire的部分key，随机删除</p>
<ul>
<li><strong>volatile-ttl</strong></li>
</ul>
<p>只限于设置了expire的部门；优先删除剩余时间短的key</p>
<p>如果没有设置 <strong>expire</strong> 的key, 不满足先决条件(prerequisites); 那么 <strong>volatile-lru</strong>, <strong>volatile-random</strong> 和 <strong>volatile-ttl</strong> 策略的行为, 和 <strong>noeviction(不删除)</strong> 基本上一致。</p>
<h4 id="内存淘汰的实现"><a href="#内存淘汰的实现" class="headerlink" title="内存淘汰的实现"></a>内存淘汰的实现</h4><p>淘汰过程：</p>
<ul>
<li>客户端执行命令，导致redis中的数据增加，内存增加</li>
<li>Redis检查内存使用量，超过maxmemory限制，根据策略清除key</li>
</ul>
<h4 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h4><p>为了节约内存，采用了抽取少量的key样本，然后删除其中访问时间最久的key。</p>
<p>在 Redis 的 LRU 算法中, 可以通过设置样本(sample)的数量来调优算法精度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples &lt;count&gt;</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/05/19/leetcode两数相加/">Letcode 两数相加</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-19T13:35:20.000Z" itemprop="datePublished">2020-05-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/algorithm/">algorithm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="leetcode-两数相加"><a href="#leetcode-两数相加" class="headerlink" title="leetcode 两数相加"></a>leetcode 两数相加</h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>

<ol>
<li>这道题比较简单，主要是考链表的，下面是自己写的</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l3 = <span class="literal">None</span></span><br><span class="line">        pre1 = l1</span><br><span class="line">        pre2 = l2</span><br><span class="line">        pre = l3</span><br><span class="line">        jin = <span class="number">0</span>									<span class="comment"># 进位</span></span><br><span class="line">        <span class="keyword">while</span> pre1 <span class="keyword">and</span> pre2:</span><br><span class="line">            s = pre1.val + pre2.val + jin</span><br><span class="line">            <span class="keyword">if</span> s &gt;= <span class="number">10</span>:</span><br><span class="line">                jin = int(s / <span class="number">10</span>)</span><br><span class="line">                s = s % <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                jin = <span class="number">0</span></span><br><span class="line">            cur = ListNode(s)</span><br><span class="line">            <span class="keyword">if</span> pre:</span><br><span class="line">                pre.next = cur</span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l3 = cur</span><br><span class="line">                pre = cur</span><br><span class="line">            pre1 = pre1.next</span><br><span class="line">            pre2 = pre2.next</span><br><span class="line">            </span><br><span class="line">        left = pre1 <span class="keyword">if</span> pre1 <span class="keyword">else</span> pre2</span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            s = left.val + jin</span><br><span class="line">            <span class="keyword">if</span> s &gt;= <span class="number">10</span>:</span><br><span class="line">                jin = int(s / <span class="number">10</span>)</span><br><span class="line">                s = s % <span class="number">10</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                jin = <span class="number">0</span></span><br><span class="line">            cur = ListNode(s)</span><br><span class="line">            pre.next = cur</span><br><span class="line">            pre = pre.next</span><br><span class="line">            left = left.next</span><br><span class="line">        <span class="keyword">if</span> jin != <span class="number">0</span>:</span><br><span class="line">            cur = ListNode(jin)</span><br><span class="line">            pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> l3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下面是参考别人写的，简洁</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = ret</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            x = <span class="number">0</span> <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> l1.val</span><br><span class="line">            y = <span class="number">0</span> <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> l2.val</span><br><span class="line">            s = x + y + carry</span><br><span class="line">            carry = int(s / <span class="number">10</span>)</span><br><span class="line">            cur.next = ListNode(s % <span class="number">10</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span> carry != <span class="number">0</span>:</span><br><span class="line">            cur.next = ListNode(carry)</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure>


        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/05/18/leetcode两数之和/">Letcode 两数之和</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-18T15:55:20.000Z" itemprop="datePublished">2020-05-18</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/algorithm/">algorithm</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="Letcode-两数之和"><a href="#Letcode-两数之和" class="headerlink" title="Letcode 两数之和"></a>Letcode 两数之和</h3><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<ol>
<li>最简单的暴力解法</li>
</ol>
<p>最容易想到的，但是内存耗时都是比较高的，这是一般人的解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        ret = []</span><br><span class="line">        ok = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            other = target - nums[index]</span><br><span class="line">            start = index</span><br><span class="line">            <span class="keyword">while</span> start &lt; len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[start + <span class="number">1</span>] == other:</span><br><span class="line">                    ret.append(index)</span><br><span class="line">                    ret.append(start + <span class="number">1</span>)</span><br><span class="line">                    ok = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ok:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>简便解法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num_map = &#123;&#125;</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            other = target - num</span><br><span class="line">            <span class="keyword">if</span> num_map.get(other) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:	<span class="comment"># 注意0</span></span><br><span class="line">                <span class="keyword">return</span> [num_map.get(other), index]</span><br><span class="line">            num_map[num] = index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>一次循环，把遍历过的每个数的差与当前数字的索引放入字典，后面如果有数字存在在字典中，则该index与字典中保存的index为结果</p>
<p>我真的是被自己蠢哭，花了一个小时，弄懂了两个算法；</p>
<p>深感有心无力，年龄大了，老程序员脑子不灵光了。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2020/05/03/install-centos8-docker/">体验CENTOS 8 并安装Docker</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2020-05-03T03:08:51.000Z" itemprop="datePublished">2020-05-03</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/linux/">linux</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="体验CENTOS-8-并安装Docker"><a href="#体验CENTOS-8-并安装Docker" class="headerlink" title="体验CENTOS 8 并安装Docker"></a>体验CENTOS 8 并安装Docker</h3><h4 id="安装CentOS-8"><a href="#安装CentOS-8" class="headerlink" title="安装CentOS 8"></a>安装CentOS 8</h4><p>背景： 五一假期闲来无事，把自己的一台老本安装了centos8最新的系统玩玩。</p>
<ol>
<li>去官网下载了最新的centos系统，太慢了，就到阿里云镜像中心下载，真是快，附上地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.aliyun.com/centos/8.1.1911/isos/x86_64/</span><br></pre></td></tr></table></figure>

<p>有包含所有软件的版本，有网络安装的版本，dvd版本的太大 7G，就选择了boot版本的，网络安装吧</p>
<ol start="2">
<li><p>坑一堆</p>
<p>以前安装系统都是通过GRUB引导安装，现在命令统统忘记，折腾半天，总是启动失败 :(</p>
<p>有知道的可以告诉我，感谢！</p>
<p>太折腾了，就选择了一种简单的方式，UtrolISO烧录到U盘，直接安装，然而我太幼稚了，还是报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no floppy found please insert floppy and go on....</span><br></pre></td></tr></table></figure>

<p>就是说没有软盘，我纳闷了，怎么会出现软盘错误。。。</p>
<p>后来去看了isolinux的启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS Linux 8</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS-8-1-1911-x86_64-dvd quiet</span><br></pre></td></tr></table></figure>

<p>发现有个LABEL的选项，但是前面有个HD的选项，怎么会去找软盘，纳闷了，可能是遗留的问题，默认都是软盘，就把这个选项改下， 改成自己的U盘。我的u盘是hdb4；这里如果不知道可以让启动失败，等待几分钟后就会出现命令行模式，可以输入命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/hd* # 查看当前挂在的磁盘</span><br></pre></td></tr></table></figure>

<p>于是就把配置文件修改为，顺利启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS Linux 8</span><br><span class="line">  kernel vmlinuz</span><br><span class="line">  append initrd=initrd.img inst.stage2=hd:/dev/hdb4 quiet</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于我选的是网络安装版本的，后面会出现填写repo文件的网络地址，默认是会有个CLOSEST mirror，可以自己安装成功；如果网络失败，可以填写阿里云的repo文件</p>
<p><a href="https://mirrors.aliyun.com/centos/8/BaseOS/x86_64/os/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/8/BaseOS/x86_64/os/</a></p>
</blockquote>
</li>
</ol>
<p>终于安装成功</p>
<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>刚开始不知道阿里云也是有docker的镜像的，就从官网粘贴的配置docker镜像源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>意外的是，竟然报错了</p>
<p><img src="/2020/05/03/install-centos8-docker/20200226175155741.png" alt="img"></p>
<p>就是说containerd.io需要1.2.2-3以上的版本</p>
<p>难道镜像源中不满足，又纳闷，还是去官网下载了1.2.2-3版本，地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.13-3.1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>当然，可能很慢，就找了阿里云的，自己选择版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/</span><br></pre></td></tr></table></figure>

<p>继续，下载了rpm包以后，就直接安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh containerd.io-1.2.13-3.1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>问题还是有的。centos8自带了一个runc也是用来跑容器的，跟docker是类似的，然而我想用docker，就直接卸载吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove runc</span><br></pre></td></tr></table></figure>

<p>再安装就ok了</p>
<p>同时，把yum的repo也改下，改成阿里云的，速度不是一般的快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>终于安装成功，启动docker daemon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h4 id="普通用户运行docker"><a href="#普通用户运行docker" class="headerlink" title="普通用户运行docker"></a>普通用户运行docker</h4><p>docker启动后，默认只有root才可以使用，其他都会提示 “no permission…”</p>
<p>看docker的通信sock，明显是属于root的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /var/run/docker.sock</span><br><span class="line">srw-rw----. 1 root root 0 May 25 14:43 /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<p>添加docker用户组，把需要使用docker的用户添加到docker组 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd docker</span><br><span class="line">gpasswd -a gfshi docker</span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<p>普通用户也可以使用了～</p>
<p>可以玩docker了 </p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/10/15/mysql-password/">mysql8/mysql 5.7.24基本操作</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-10-15T03:08:51.000Z" itemprop="datePublished">2019-10-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/service/">service</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>最近使用ubuntu 18.04LST 安装mysql，设置密码，搞得我怀疑人生，搞半天是设置密码的方式在mysql8中改变；记录下问题的过程及设置密码</p>
<h4 id="密码咋修改不了"><a href="#密码咋修改不了" class="headerlink" title="密码咋修改不了"></a>密码咋修改不了</h4><p>之前在使用MySQL的时候，都是使用grant/alter/set 去修改root的密码的，今天安装了5.7.29，使用同样的方法修改，一直修改失败，系统账户root登录mysql不需要密码，普通用户无法登录</p>
<p>使用grant修改密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select User,Host,authentication_string from user;</span><br><span class="line">+------------------+-----------+-------------------------------------------+</span><br><span class="line">| User             | Host      | authentication_string                     |</span><br><span class="line">+------------------+-----------+-------------------------------------------+</span><br><span class="line">| root             | localhost | *000BFFBA444B9D1E98861B0537ABAA4664A2CAA1 |</span><br><span class="line">| mysql.session    | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">| mysql.sys        | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">| debian-sys-maint | localhost | *87BD4C29046C1B2C43D1FB7342F5F1BA286253BC |</span><br><span class="line">+------------------+-----------+-------------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;   grant all on *.* to &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>执行没有返回错误，退出后重启MySQL，发现密码并没有修改；</p>
<p>于是觉得自己是不是没有操作成功，重新执行了两边，未果；</p>
<p>于是乎，换了一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>同样，操作了两边，还是未果；</p>
<h4 id="执行后看返回"><a href="#执行后看返回" class="headerlink" title="执行后看返回"></a>执行后看返回</h4><p>后来在某次执行发现，有一个warning，两个执行都有返回，就看了这两个warnings</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;   grant all on *.* to &apos;root&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+---------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                            |</span><br><span class="line">+---------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1287 | Using GRANT statement to modify existing user&apos;s properties other than privileges is deprecated and will be removed in future release. Use ALTER USER statement for this operation. |</span><br><span class="line">+---------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Using GRANT statement to modify existing user’s properties other than privileges is deprecated and will be removed in future release. Use ALTER USER statement for this operation.</p>
<p>就是说，grant已经要废弃了，要用alter User 修改</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings</span><br><span class="line">    -&gt; ;</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                                                                                                                                 |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1287 | &apos;SET PASSWORD FOR &lt;user&gt; = PASSWORD(&apos;&lt;plaintext_password&gt;&apos;)&apos; is deprecated and will be removed in a future release. Please use SET PASSWORD FOR &lt;user&gt; = &apos;&lt;plaintext_password&gt;&apos; instead |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>‘SET PASSWORD FOR <user> = PASSWORD(‘<plaintext_password>‘)’ is deprecated and will be removed in a future release. Please use SET PASSWORD FOR <user> = ‘<plaintext_password>‘ instead </plaintext_password></user></plaintext_password></user></p>
<p>这种设置密码的方式也已经被废弃了，要使用 </p>
<p> SET PASSWORD FOR <user> = ‘<plaintext_password>‘</plaintext_password></user></p>
</blockquote>
<p>不过warnings只是警告，执行是成功的，只是说下一版本要去掉PASSWORD，继续查找问题。</p>
<p>好，那就用明文的方式再试一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos;=&apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>又出现一个warnings，那就再看下有什么warnings的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos;=&apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                                                                                    |</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Note  | 1699 | SET PASSWORD has no significance for user &apos;root&apos;@&apos;localhost&apos; as authentication plugin does not support it. |</span><br><span class="line">+-------+------+------------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SET PASSWORD has no significance for user ‘root’@’localhost’ as authentication plugin does not support it.</p>
<p>plugin不支持set password</p>
</blockquote>
<p>那就看下当前用户的plugin，刚好user里面有一列plugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select Host,User,plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| Host      | User             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| localhost | root             | auth_socket           |</span><br><span class="line">| localhost | mysql.session    | mysql_native_password |</span><br><span class="line">| localhost | mysql.sys        | mysql_native_password |</span><br><span class="line">| localhost | debian-sys-maint | mysql_native_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>目测是这个plugin的问题，那就修改下plugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user mysql;</span><br><span class="line">update user set plugin=&quot;mysql_native_password&quot; where User=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>修改完后重启mysql</p>
<h4 id="终于成功修改密码"><a href="#终于成功修改密码" class="headerlink" title="终于成功修改密码"></a>终于成功修改密码</h4><p>修改plugin成功后，这些密码修改的命令都可以使用了，终于，密码修改成功了</p>
<h5 id="方法1，使用set-password-for-使用明文"><a href="#方法1，使用set-password-for-使用明文" class="headerlink" title="方法1，使用set password for ,  使用明文"></a>方法1，使用set password for ,  使用明文</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for &apos;root&apos;@&apos;localhost&apos;=&apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="方法2-，alter-user"><a href="#方法2-，alter-user" class="headerlink" title="方法2 ，alter user"></a>方法2 ，alter user</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;P@55word&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h4><ol>
<li>查看索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from [table name];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX 索引名 ON 表名</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查询语句是否命中索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">explain [sql]</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from sentence_daily where date_str=&apos;2019-10-25&apos;;（命中索引date_str_type）</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table          | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | sentence_daily | NULL       | ref  | date_str_type | date_str_type | 50      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+---------------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from sentence_daily where type=1;(未命中)</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table          | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | sentence_daily | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  101 |    10.00 | Using where |</span><br><span class="line">+----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>


        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/09/18/redis-HA/">redis 高可用系统</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://shiguofu2012.github.io/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-09-18T06:39:09.000Z" itemprop="datePublished">2019-09-18</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/redis/">redis</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h4 id="Redis的高可用方案有三种："><a href="#Redis的高可用方案有三种：" class="headerlink" title="Redis的高可用方案有三种："></a>Redis的高可用方案有三种：</h4><ul>
<li>master/slave主从方案</li>
</ul>
<p>主节点提供读写操作，从节点提供读操作；</p>
<p>主节点故障，需要手动主备切换；</p>
<p>读写主还是从，由客户端控制；</p>
<ul>
<li>哨兵(sentinel)模式来进行主从替换以及故障恢复</li>
</ul>
<p>在主从模式的基础上增加sentinel监听，主节点不可用，自动将slave提升为master;</p>
<p>客户端通过sentinel获取主/从节点；</p>
<ul>
<li>redis cluster集群方案</li>
</ul>
<p>去中心化，平等结构，数据槽；</p>
<p>这里主要介绍下，简单的主从模式与sentinel结构；</p>
<h3 id="redis-master-slave-（replication）"><a href="#redis-master-slave-（replication）" class="headerlink" title="redis master/slave （replication）"></a>redis master/slave （replication）</h3><p>master/slave 是为了解决点单故障而出现的，slave是对master的镜像；</p>
<h4 id="主要工作机制"><a href="#主要工作机制" class="headerlink" title="主要工作机制"></a>主要工作机制</h4><ul>
<li>master-slave使用异步方式复制数据，同样使用异步的确认slave-to-master</li>
<li>一个master可以拥有多个slave</li>
<li>slave也可以连接slave （4.0以后，所有的sub-slaves从maser接受复制数据）</li>
<li>master在做复制操作的时候，不会block master的读写操作</li>
<li>slave在复制操作过程中，根据配置使用旧的数据提供服务或者返回错误(配置replica-serve-stale-data)；完成复制后，旧的数据会被删除，新的会被加载，期间会拒绝连接( block incoming connections)</li>
<li>slave可做横向扩容或者数据的安全性与高可用</li>
<li>master可关闭持久化，直接内存读写，slave开启持久化，保存数据；<strong>注意master重启，slave也会同步空的数据</strong></li>
</ul>
<h4 id="redis-replication-工作原理"><a href="#redis-replication-工作原理" class="headerlink" title="redis replication 工作原理"></a>redis replication 工作原理</h4><ul>
<li>两个参数确定了同步的信息</li>
</ul>
<p>replication ID: 伪随机数，与当前数据集生成，每个master具有</p>
<p>offset：master/slave 之间同步的位置记录</p>
<p>当slave连接到master后，使用<strong>PSYNC</strong>命令发送当前master 的replication ID与offset</p>
<ul>
<li>正常情况，master发送增量数据给slave，offset开始</li>
<li>slave发送无效的replication ID/master没有足够的backlog，会开始全量复制(full resynchronization)</li>
</ul>
<h5 id="全量复制的过程"><a href="#全量复制的过程" class="headerlink" title="全量复制的过程"></a>全量复制的过程</h5><ol>
<li>master接受到全量复制的请求，启动<strong>bgsave</strong>进程生成rdb file；同时，会开启一个<strong>buffer</strong>缓存所有新的写命令</li>
</ol>
<blockquote>
<p>关于buffer的配置：</p>
<p>client-output-buffer-limit replica 256MB 64MB 60</p>
<p>如果在复制期间，内存缓冲区超过60秒一直消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。后两个参数是配合使用的，假如：消耗超过64MB 一直持续了59秒，但是60秒的时候不超过64MB了，那么就保持连接继续复制。</p>
</blockquote>
<ol start="2">
<li><p>bgsave完成后，master会将rdb file 给slave；slave会将其<strong>存到磁盘并加载到内存</strong></p>
</li>
<li><p>master 发送缓存的命令给slave</p>
</li>
</ol>
<p>下面为master的日志记录，同步的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3829:M 10 Oct 2019 14:47:08.193 * Replica 10.226.50.31:6379 asks for synchronization</span><br><span class="line">3829:M 10 Oct 2019 14:47:08.193 * Full resync requested by replica 10.226.50.31:6379</span><br><span class="line">3829:M 10 Oct 2019 14:47:08.193 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">3829:M 10 Oct 2019 14:47:08.194 * Background saving started by pid 4102</span><br><span class="line">4102:C 10 Oct 2019 14:47:09.637 * DB saved on disk</span><br><span class="line">4102:C 10 Oct 2019 14:47:09.637 * RDB: 6 MB of memory used by copy-on-write</span><br><span class="line">3829:M 10 Oct 2019 14:47:09.685 * Background saving terminated with success</span><br><span class="line">3829:M 10 Oct 2019 14:47:09.731 * Synchronization with replica 10.226.50.31:6379 succeeded</span><br></pre></td></tr></table></figure>

<h5 id="无盘化复制"><a href="#无盘化复制" class="headerlink" title="无盘化复制"></a>无盘化复制</h5><p>正常情况下，全量复制需要在磁盘上创建rdb文件，并从磁盘上读取该文件发送给slave</p>
<p>磁盘效率低下，会严重影响master的效率，可配置不经过磁盘，直接发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br><span class="line"></span><br><span class="line"># 等待 5s 后再开始复制，因为要等更多 replica 重新连接过来</span><br><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>不建议使用slave作为master的热备，关掉master的持久化；master宕机后会立马同步到slave导致数据丢失</li>
<li>master的备份方案需要做，防止本地文件丢失；sentinel可以监控并切换，但有可能master failure还未检测到就已经重启，也会导致情况1</li>
</ol>
</blockquote>
<h5 id="至少N个slave才能写成功"><a href="#至少N个slave才能写成功" class="headerlink" title="至少N个slave才能写成功"></a>至少N个slave才能写成功</h5><p>Redis 2.8开始，可以配置至少有N个slave连接的情况下，master才能接受写请求</p>
<p>由于redis使用异步复制，不能保证slave真正接受到了某个写请求，于是有可能有一个丢失窗口</p>
<p>工作特点：</p>
<ul>
<li>slave每秒钟ping master，确认复制的数据的数量</li>
<li>master记录每个slave最后一次ping的时间</li>
<li>用户可配置不大于最大秒数的延迟的最小的slave数量</li>
</ul>
<p>如果有N个slave，延迟小于M秒，则写入成功；否则返回错误，写入失败</p>
<p>redis配置参数：</p>
<ul>
<li>min-slaves-to-write <code>&lt;number of slaves&gt;</code></li>
<li>min-slaves-max-lag <code>&lt;number of seconds&gt;</code></li>
</ul>
<h5 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h5><ul>
<li>replica不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给replica</li>
<li>master过期数据，因此在slave内存中可能存在逻辑上已经过期的数据还未及时被删除，slave中使用(its logical clock)<strong>only for read operations</strong>确定key不存在，不违反一致性</li>
<li>Lua脚本执行期间不会执行过期策略；发送同样的Lua脚本到slave保证一致性</li>
</ul>
<h5 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h5><p>主从节点互相都会发送 heartbeat 信息。</p>
<p>master 默认每隔 10秒 发送一次 heartbeat，replica node 每隔 1秒 发送一个 heartbeat。</p>
<h4 id="redis-replication-配置"><a href="#redis-replication-配置" class="headerlink" title="redis replication 配置"></a>redis replication 配置</h4><p>配置是比较简单的，了解基本原理主要是为了在出现问题时，能够快速定位问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">replicaof 10.226.50.31 6381</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># master 配置认证密码</span><br><span class="line"># requirepass foobared</span><br><span class="line"># slave 认证</span><br><span class="line"># masterauth foobared</span><br></pre></td></tr></table></figure>

<p>replicaof [ip] [port]</p>
<p>在5.0.4之前使用的时slaveof; </p>
<p>修改配置的bind/port/logfile/dbfilename/dir等配置参数，启动redis</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis-6379.conf</span><br><span class="line">redis-server /etc/redis-6381.conf</span><br></pre></td></tr></table></figure>

<p>启动后查看redis的replication 6379, 角色为slave；写入数据报错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="meta">#</span> Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:10.226.50.31</span><br><span class="line">master_port:6381</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:10</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:128880</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:a868c97d4f90ce5e77d6d6bd1787e8f61df35eff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:128880</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:128880</span><br><span class="line">127.0.0.1:6379&gt; set a b</span><br><span class="line">(error) READONLY You can't write against a read only replica.</span><br></pre></td></tr></table></figure>

<p>master的角色为master，存在master replid，slave 同步的位置offset；写入数据成功，查看slave，数据已经同步</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# redis-cli -p 6381</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="meta">#</span> Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=10.226.50.31,port=6379,state=online,offset=128978,lag=0</span><br><span class="line">master_replid:a868c97d4f90ce5e77d6d6bd1787e8f61df35eff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:128978</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:128978</span><br><span class="line">127.0.0.1:6381&gt; set a b</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="redis-sentinel"><a href="#redis-sentinel" class="headerlink" title="redis sentinel"></a>redis sentinel</h3><p>Sentinel(哨兵)是用于监控redis集群中Master状态的工具，sentinel哨兵模式已经被集成在redis2.4之后的版本中。</p>
<p>sentinel进程可以监视一个或者多个redis master/slave服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。</p>
<p>写博客太需要时间，未完，待续。。。</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://shiguofu.cn" target="_blank">carlshi</a>,  <a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备18003559号-1</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
